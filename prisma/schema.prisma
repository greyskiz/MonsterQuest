generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Tier {
  QUICK
  STANDARD
  LONG
}

enum Scope {
  SOLO
  PARTY
}

enum EncounterStatus {
  ONGOING
  PAUSED
  COMPLETED
  ABANDONED
}

model User {
  id           String   @id @default(uuid())
  username     String   @unique
  email        String   @unique
  passwordHash String
  role         String   @default("USER")
  displayName  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  encounters   Encounter[]
  defeats      UserMonsterDefeat[]
  participants EncounterParticipant[]
  inventory    UserInventory[] // items owned
  avatar       Avatar?         // a user must have one avatar

  @@index([username])
  @@index([email])
}

model MonsterTemplate {
  id        String   @id @default(uuid())
  name      String   @unique // prevent duplicate monster names
  tier      Tier
  scope     Scope
  minutes   Int
  baseCoins Int?
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  encounters Encounter[]
  defeats    UserMonsterDefeat[]
}

model Encounter {
  id              String          @id @default(uuid())
  userId          String
  monsterId       String
  status          EncounterStatus // <â€” use enum not String
  startedAt       DateTime        @default(now())
  finishedAt      DateTime?
  plannedDuration Int // minutes planned for this session
  elapsed         Int             @default(0) // minutes elapsed (heartbeat)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  user    User                   @relation(fields: [userId], references: [id])
  monster MonsterTemplate        @relation(fields: [monsterId], references: [id])
  members EncounterParticipant[] 

  @@index([userId])
  @@index([monsterId])
  @@index([status])
}

model EncounterParticipant {
  id          String   @id @default(uuid())
  encounterId String
  userId      String
  joinedAt    DateTime @default(now())

  encounter Encounter @relation(fields: [encounterId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  @@unique([encounterId, userId]) 
  @@index([userId])
  @@index([encounterId])
}

model UserMonsterDefeat {
  id         String   @id @default(uuid())
  userId     String
  monsterId  String
  defeatedAt DateTime @default(now())

  user     User            @relation(fields: [userId], references: [id])
  template MonsterTemplate @relation(fields: [monsterId], references: [id])

  @@unique([userId, monsterId]) 
  @@index([userId])
  @@index([monsterId])
}


//Represents all items available in the shop (what can be bought)
model shopItem {
  id        String   @id @default(uuid())
  name      String
  slot      String   // e.g. "head", "body", "weapon"
  price     Int      // cost in coins
  rarity    String   // e.g. "common", "rare", "legendary" (only for aesthetic purposes)
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ownedBy UserInventory[]   @relation("ItemOwnership")   // which users own this item
  equippedAsHead Avatar[]   @relation("HeadItem")        // avatars using as head
  equippedAsBody Avatar[]   @relation("BodyItem")        // avatars using as body
  equippedAsWeapon Avatar[] @relation("WeaponItem")      // avatars using as weapon
}


//Tracks the shop items users own (note: 1 shop item can be owned by more than 1 user, but a user cannot have more than 1 item of the same type)
model UserInventory {
  id              String   @id @default(uuid())
  userId          String
  inventoryItemId String
  acquiredAt      DateTime @default(now())

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  item           shopItem       @relation(fields: [inventoryItemId], references: [id], name: "ItemOwnership")

  @@unique([userId, inventoryItemId]) // user cannot own the same item twice
}


//Represents the current shop items the users chose to equip their avatar
model Avatar {
  id      String @id @default(uuid())
  userId  String @unique
  name      String   // user-defined name
  imageUrl  String   // user-chosen picture
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Slots (shop items will be null at first when avatar is first created, user must earn coins from fighting monsters to get items)
  headId   String?
  bodyId   String?
  weaponId String?

  user   User           @relation(fields: [userId], references: [id])
  head   shopItem ?      @relation("HeadItem", fields: [headId], references: [id])
  body   shopItem ?      @relation("BodyItem", fields: [bodyId], references: [id])
  weapon shopItem ?      @relation("WeaponItem", fields: [weaponId], references: [id])

}